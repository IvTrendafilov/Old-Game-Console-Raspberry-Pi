# Final Project Plan report

|                  | **Names/Ids**  |
|-----------------:|:---------------|
| *Team ID:*       |       28         |
| *Team Members:*  |        Pavel Hristov, Stefan Ilich, Ivan Ivanov, Vladislav Avramov, Tudor Nechtiti, Stefan Simonescu        |
| *Scrum  Mentors:*|      Stephan Leinweber, Sibren Vasse          |

**Project Title:**

## 1. Introduction and Background
The modern day and age is like all times before it - a lot of things learned throughout the years combined with bold ideas for the future. In our case we started examining how the past and the future of gaming can be combined. In our search we discovered the missing bridge between old and new, meaning that the younger generations can’t or just don’t try stuff from the past, even though some games from that era are still to this day historical and deserve the attention. Observing what the younger generation likes we found out that younger kids generally enjoy playing games on their phone/tablet with the integrated touch, but also occasionally like playing on their home consoles. In that sense we came up with the conclusion that there is no product that can be easily accessible for younger generations to try old classic games, while providing them with familiar control configuration that they enjoy day to day. In the process we also saw the demand of mature people who grew up playing those games and would love to revisit them or just can’t find them in an accessible fashion any more. For them, our idea also worked – providing new spin for something they have adored for generations. We found the idea fascinating and wanted to start developing it because as a generation between those two vastly different periods of gaming we could see both sides of the coin – the mature people with their passion for amazing games and also the younger impatient generation that also found those games interesting but would love them on newer hardware. The final idea came in the form of a home console with an ever expanding library of classic old school games plus some new, providing the simplicity of an old school console with the versatility of modern touch controls.


## 2. Project Plan and Scope
The scope of our project was laid out rather early in the process. We conducted multiple meetings and discussed ways of implementing and delivering a stable product. In the process we agreed on the baseline of a system with 4 touch inputs for gaming and 2 games to come as a standard on the console. Furthermore, we discussed ways we can improve the console from this MVP. In the discussion the idea of more than 2 standard games rose and that was recognized as a priority if the time allows it; from there the ideas of additional high score boards came up (storing high scores of all players playing on that console), additional difficulty settings and further additions/game modes added to the system after the MVP is completed. The deliverables were divided per sprint – firstly we needed to present our initial idea along with design documentation to accompany that. While working on that we also needed to start the implementation phase (of hardware and software). In our second week we had to supply the needed sensors (in our case touch) and start working with them. At the end of week 2, we decided to try and show the sensors and that we’ve successfully started working with them. After that, for our third sprint we acknowledged that with the working hardware we had to start developing software as well, in that case start implementing a menu interface and start development of the first game, if everything went as planned. In the process of discussing those ideas, we decided to limit the scope of the deliverable this week to just a functional game and also a working interface, so we could be most certain that we’ll achieve our goals. From there we needed to continue with finishing touches on game 1 and develop game 2 throughout the next sprint, coming to the MVP we decided in the beginning – a game console controlled by touch sensors with simple interface and at least two games available to be played on it.

## 3. Brief description of the hardware (Raspberry Pi) and software
The hardware that we are using is:
We are using one Raspberry Pi 4 with 4GB of RAM. We are using only one because it provides enough power for the touch sensors. We are using three to four touch sensors which model is Capacitive touch sensors TTP 223. The touch sensors are connected to a big breadboard which is also connected to the Raspberry Pi. The touch sensors are used for navigation in the games and between the games in the user interface. We are also using a display. Doesn’t matter if it’s a laptop monitor, a pc monitor or a TV. As long as the Raspberry is connected to it so that it can display the user interface and games everything’s fine.
Software that we are using is:
The code for the games is created in Python and more precisely in Pygame or Pycharm depending on the team member. Pygame is a module of Python or more precisely which is designed for writing video games in cross-platform. We are also using VNC Viewer which is used to make a connection between the Raspberry and the monitor so that the user interface and games can be displayed.  

## 4. Application Specification
The basic idea behind our application is a home console that provides stable and fun experiences to players. In part that means that we have to have a robust design process and realization in order to achieve those goals. The first specifics come in the department of hardware provision.
We had to come up with a hardware solution that was both fully functional and easy to use. In practice we used types of different sensors to try and find the one that is most useful and fitted all use cases. Specifically as we researched and tried different sensors (motion, proximity, touch) and we research which was most useful. In our case the sensors are touch, which in turn allows all users to start using something that they use in their day to day lives, e.g. smartphones, tablets, some laptops. In that way a younger users are greeted with something new age and familiar to them, while old school players are greeted with something that is now part of their lives, they are also familiar with it, while also maintaining the freshness of a type of controls they haven’t use to revisit their favorite classics from their teenage years. Shortly put, touch sensors allow us to create a functional, fun, yet familiar way of interaction with the console for both young and mature audiences.
As for the software, it is the direct impression of the system for our users. Specifically speaking our system had to have a nice looking, easy to understand and use, fast and responsive UI that provided the needed options to the users. We tested multiple different UI interfaces so we can find the one that is both easy to develop for us and also easy to use and responsive for our users. We stuck to the py-game menu library extension of Python. In our case that allowed us to be able to quickly develop a fully functional solution that our users can find both cool and understandable. For us that also opened the door to fast integration between sensors, games and UI, because we use a Python library to integrate our sensors, and also use Python to develop the games to be played. All those things combined help both us (developers) and users. For us this helps us speed up the process of development, since all our components use Python, which on its own is fast enough for our needs, while also allowing us to work around bottlenecks of having a lot of different languages integrated together. For the end consumer that meant a fast and responsive system that could be easily upgradeable, fixes would be rather easy to implement, leading to an overall stable and robust system for them to use day to day.


## 5. Design (How to map application onto Hardware and Software)
To begin with, we will explain what hardware and software we use for our design. Our game console has a user interface and a few games. The software used for the implementation is the pygame library for the games and the pygame_menu library for the user interface. For navigation through the interface and playing games touch sensors are used and for that we need the GPIO from the Raspberry Pi.
We also have three UML diagrams which are pretty straightforward and explain our design.Our main actor is the player who interacts with our system(gaming console) by playing various games. Our Activity diagram shows what steps a player follows when he is using our console. When he turns it on he can enter settings or pick a game. Then he will play until he has lost and his score will be displayed afterwards. After finishing the game, he can try again or pick a different one. 
Then we have our Use case diagram which is pretty similar. It shows all activities the player can do while using our system like playing a game, finishing a game , and entering settings.
Our last diagram is the Sequence diagram. The purpose of this diagram is to show how things will look on the technical side. It demonstrates how the player at first enters the  main interface and from there he can navigate to the settings or start a game. While in our main menu the touch sensors will be taking input in order to navigate through the widgets and sensors will be used for picking a widget. After picking a game, the player will then exit our menu and go to our game. While in game the touch sensors will become controls and will be taking input which will be used to move an in-game character.

## 6. Implementation (How to implement the different parts)
We will now go over the implementation of our project and requirements needed to use our game console for playing games. We need a Raspberry Pi 4 connected to a laptop or a monitor to connect the RPi to. If one chooses to connect the Rpi to the laptop, one would need to install a VNC viewer in order to start our game console. Last but not least, we need at least 3 touch sensors, along with a breadboard, resistors and cables. We used the pygame library to create our retro games for the console and the library pygame_menu to create the user interface of our console. We chose to use them because pygame was specifically integrated into the Raspberry Pi and Python made it easy for us to learn game development fast. So our first objective was to create our interface and a working game. After that we integrated the two so that a player can start the game through the user interface. At first we used a normal keyboard for the game before switching to the Raspberry Pi with touch sensors. After fixing all bugs from our main menu and having two working games we started integrating the sensors. This means that we will be using the GPIO pins of RPi in order to use touch sensors to navigate through the user interface and play games. We integrated the sensors by importing the GPIO library into our games and checking for input from the touch sensors. For example we have a sensor that simulates a ArrowDown keypress. It must be connected to a Ground pin, one of our specified GPIO pins and voltage pin(3.3 or 5). The capacitive touch sensors we use can handle up to 5.5v so using the 5v pin is not a problem.Our GPIO pins are 13,15,40. These are the pins that players will have to connect the touch sensors to. Keep in mind this is the physical number of the pins.  By holding your finger near the touch sensor you trigger an input which will simulate a keypress and do certain actions on our console. After correctly connecting the sensors, all you need to do is run our main method which will start the console. You can do that either on a separate monitor or on the VNC viewer if your Rpi is connected to your laptop.

## 7. Testing
From the start we decided that with the short periods we had to deliver MVPs we had to think of a stable way to test our project’s different components. We had to start from the hardware part. In order to ensure that we had a good understanding of the work with the sensors and also they weren’t faulty we had to do loads of tests. For the basics, what we also presented, was the test that the sensors were simply registering correctly. Furthermore, we did a test with measuring time for reaction of a sensor, meaning how much time does it take for each sensor to register a touch – all sensors should register roughly equivalent times in order to be verified as correctly working. And finally we did a test where we verified ourselves from 50 taps that every sensor registered correctly at least 97% of taps and lift-ups.
           	For the software part we also had to do our QA and testing very strictly. First of all we had to create the interface that the player would be greeted with and ensure that it is as easy and as reliable and functional as possible. We did that by creating and testing multiple frameworks and their performance on the Pi, but ultimately landed on pygame-menu after a lot of performance tests. Furthermore, for our games tests, initially some are developed on a PC first in an optimal environment in order for the raw development process to be fast, as well as bug fixing. From there a deployment phase is initiated with full testing. After a game is successfully deployed on our system, the process continues with multiple game runs from different people. If any bug or glitch is found first of all, the person/team that developed it can start working on a fix right away.
           	In general our strategy, in order to achieve real console-like experience, was to always use the right tools, test as much and as frequently as possible and fix bugs as soon as found. In that way, we ensured a stable and responsive gameplay experience to our players.

## 8. Planning and definition of tasks for the individual members
We had a lot of meetings outside of the ones planned from the university in which we discussed how we should manage the deadlines that we have and how we are going to divide the tasks between the team members. We communicated a lot and in the end we made sure that the planning would be based on the decision of dividing the tasks. We think that when everyone has a different task on which he has to work and later combine them would be the most time efficient way of solving stuff. We decided that every member or a group of two members will get a different task depending on what they want to do and what they are willing to do. Examples of all this planning and dividing is:
Pavel Hristov and Stefan Ilich are working on creating a user interface in which they will integrate all the games that are created by the other teams. They are also working on integrating the touch sensors with the games so that touch sensors can be used to navigate when playing a game.
Tudor Nechtiti and Stefan Simonscu are both working on 2 different games. Both of them are working on two different games and are adding different features to them so that we can implement them later in the user interface so that we can have a ready MVP for this week.
Vladi Avramov and Ivan Trendafilov are both working on the documentation. We decided that 2 members are enough to work on the documentation. They are also working on one game together in which both of them will be implementing different stuff so that later on the game can be integrated in the user interface.
If any team member has any problems with the tasks or needs help or is running late on the schedule that was created for this week all other members are ready to help him in order to meet with the deadlies.

## 9. Conclusion
On the surface, our product as a whole seems rather simple – a home console. But there is more to it – it is the bridge between the old and the new, providing the young and the mature alike with an experience worth every moment. With this console players get to enjoy touch-controlled games in a new way, never seen before. We strive to preserve gaming history, while providing nice experiences, we open the younger audiences to classics that they most likely would have never tried. While they explore these “new-old” experiences, we can provide trip down memory lane for old-school gamers who want to revisit their all-time favorites with a new spin on them.
For our project we opted to use the best available hardware for developing such platform – we needed something capable with the support for Linux kernel systems. In our search we determined the one clear winner to be the Raspberry Pi 4 (model with 4GB RAM), since that base system provided Linux support, vast range of ports, portability and swift enough processor for our needs. As for the software, we needed a robust solution that can suit all our needs – it is easy to deploy, easy to develop with and quick enough that it fulfills our speed goals. For that we chose the Python language along with the Pygame-menu extension for the UI. Developing with Python for the Pi proved fast enough, maintaining speed on the system and the ease of development and integrating different components together. All this hardware and software combine to deliver our speedy and easy to use system to our customers.
The planning regarding the project was done pretty early on. We decided on some key aspects of the system as well as target goals that we wanted to achieve during the sprints. We identified the importance of working touch sensors first and foremost, then the development of base UI for the system with the simultaneous development of the first game. From there we needed full integration between UI, game and touch sensors to provide the base MVP we wanted. In that state the system would have been fully functional and we could easily integrate more games or add new features to the games through updates.
The design part of the system we wanted to keep as clean as possible. We wanted the design to be nice and concise, nothing overly complicated. That we realized with some UML diagrams illustrating our ideas and also helping us keep track of different components, processes and overall ideas we want to integrate. Having good initial design helped us achieve our goals in a much faster and stable way, since we always had all our ideas laid out and easy to follow. What helped us the most was our sequence diagram that we used all the time to track our progress on the development and behavior of our system.
Implementation and testing also played key role in the development of our system. The implementation seemed pretty straight forward – just connect the sensors, write the code for UI and games, do some optimizations and we have a ready system. But in reality we had some challenges to overcome, but in the end the system turned out just working marvelously, software and hardware alike. Our design choices did pay their dividends in the end, as with the simple and effective design a robust product was achieved. In regard to testing we had to ensure top quality assurance, since that is the first thing consoles are known for – reliability. We did multiple QA tests on our parts, as well as thorough testing on every UI and game component alike to achieve our goal of quality.
Overall, our full strategy led to a product that exceeded our expectations – good design, planning, teamwork, tools and testing led to a system that could be use with ease and pleasure by young and mature users alike.

##  Reference

##   I. Acknowledgement
Our two TA’s  Sibren Vasse and Stefan Leinweber were really helpful with the additional feedback that they were providing. That feedback helped us plan how we should develop our project throughout the different sprints so that we would have enough time to manage with the deadlines. It also helped us stay on the right road when creating different parts of the project. Also, the student feedback that we were receiving after every sprint presentation was really helpful to us to understand what parts of our project and product look good and what parts of the project need more developing so that they could be more user friendly.


##   II. Reflection
We were able to meet all the sprint deadlines with the plan that we had. At the beginning we made a plan that was a bit too much compared to what we could handle, but with the help of our TA’s we were able to create a new schedule for the development of the project which allowed us to follow it without any problems. We had some small problems but they didn’t overcompliment the project and we were still able to manage with the planning. One of the biggest problems that we had was with the touch sensors. We burned out some of them and had to replace them which was close to putting us behind schedule but in the end we managed.


##   III. Appendix and Glossary
Some of the phrases that we are using are
User interface/game interface – it implies that we are talking about the interface that all the user can use when they run our application, in which they can choose between different games.
Controls – implies the touch sensors that we are using for the games.

   

   
